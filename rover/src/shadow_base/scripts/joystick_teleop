#!/usr/bin/env python

import rospy

from sensor_msgs.msg import Joy
from geometry_msgs.msg import Twist
from shadow_base.msg import ShadowAuxMove

class Teleop:
    def __init__(self):
        rospy.init_node('shadow_teleop')

        self.turn_scale = rospy.get_param('~turn_scale')
        self.drive_scale = rospy.get_param('~drive_scale')
        self.deadman_button = rospy.get_param('~deadman_button', 5)
        self.bucket_down_button = rospy.get_param('~bucket_down_button', 1)
	self.bucket_up_button = rospy.get_param('~bucket_up_button', 2)
	self.bucket_speed = rospy.get_param('~bucket_speed', 1)

        self.cmd = None
	self.aux_move = None
        self.joy = Joy()
        cmd_pub = rospy.Publisher('cmd_vel', Twist)
	aux_move_pub = rospy.Publisher('aux_move', ShadowAuxMove)

        rospy.Subscriber("joy", Joy, self.callback)
        
        rate = rospy.Rate(rospy.get_param('~hz', 20))
        
        while not rospy.is_shutdown():
            rate.sleep()
            if self.cmd:
                cmd_pub.publish(self.cmd)
	    if self.aux_move:
	        aux_move_pub.publish(self.aux_move)
    def callback(self, data):
        """ Receive joystick data, formulate Twist message.
        Use planner if a secondary button is pressed """
        self.joy = data
        cmd = Twist()
	aux_move = ShadowAuxMove()
        cmd.linear.x = data.axes[3] * self.drive_scale
        cmd.angular.z = data.axes[0] * self.turn_scale

	aux_move.cameraPan.x = data.axes[6];
	aux_move.cameraPan.y = data.axes[7];

	if data.buttons[self.bucket_up_button] == 1:
	    aux_move.bucketSpeed = self.bucket_speed
	elif data.buttons[self.bucket_down_button] == 1:
	    aux_move.bucketSpeed = -self.bucket_speed
	else: 
	    aux_move.bucketSpeed = 0

        if data.buttons[self.deadman_button] == 1:
            self.cmd = cmd
	    self.aux_move = aux_move	
        else:
            self.cmd = None
	    self.aux_move = None

if __name__ == "__main__": Teleop()
